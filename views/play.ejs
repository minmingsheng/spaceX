<!DOCTYPE html>
<html>
	<head>
		<title> play</title>
		<link rel="stylesheet" href="../../css/main.css">
		<script src="../../js/3js/Three.js"></script>
		<script src="../../js/3js/cannon.js"></script>
		<script src="../../js/3js/PointerLockControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react.js"></script>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>
		<script src="/socket.io/socket.io.js"></script>
	</head>
	
	<style>
	#play{
		width: 100%;
		height: 100%;
	}
	body {
	    background-color: #ffffff;
	    margin: 0;
	    overflow: hidden;
	    font-family: arial;
	}
	#blocker {

	    position: absolute;

	    width: 100%;
	    height: 100%;

	    background-color: rgba(0,0,0,0.5);

	}
	header{
		position: absolute;
		right: 0;
	}
	#instructions {

	    width: 100%;
	    height: 100%;
	
	    color: #ffffff;
	    text-align: center;
		padding-top: 100px;
	    cursor: pointer;

	}
	#choose{
		width: 400px;
		display: flex;
		height: 200px;
		margin: auto;
	}
	#radiant,#dire{
		margin:auto;
		display: block;
		width: 180px;
		/*width: 190px;*/
		border-radius: 10px;
		line-height: 180px;
		height: 180px;
		box-shadow: 1px 1px 11px rgba(0,0,0,0.5);
	}
	#instructions P{
		clear: both;
	}

	</style>
	<script type="text/javascript" >
		"use strict";
		let profilePic = "<%= profilePic %>";
		let profileName = "<%= profileName %>";
		let profileId = "<%= profileId %>";
		let host = "<%= host %>";
		let roomId = "<%= roomId %>";
		let roomName = "<%= roomName %>";
		console.log("profilePic: ", profilePic);
		console.log("profileName: ", profileName);
		console.log("profileId: ", profileId);
		console.log("host: ", host);
		console.log("roomId: ", roomId);
		console.log("roomName: ", roomName);

		// console.log(JSON.parse(roomInfo));
		let socket = io("<%= host %>"+"/multiPlay");
		socket.on('connect', function () {
		   console.log("connect to server!!!!!!");
		   socket.emit("join", {
		   	profilePic,
		   	profileName,
		   	profileId,
		   	roomId
		   })
		});
		socket.emit('playersList');
		socket.on('playersList', function(data){
			console.log(data);
			for(let prop in data){
				console.log(data[prop]);
				let div = document.createElement("div");
				div.setAttribute("class", "player");

				div.innerHTML = `<div>
							<img src=${data[prop].profilePic} alt="">
							<p>${data[prop].profileName}</p>
						</div>
						<div>####################</div>`;
				document.getElementById("userList").appendChild(div);
			}
		});



	</script>
	<body id="play">
		<div id="blocker">

		    <div id="instructions">
		    	<h1>choose your team</h1>
		    	<div id="choose">
		    		<div id="radiant"> The radiant </div>
		    		<div id="dire"> The dire </div>
		    	</div>
		        <p>(W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot)</p>
		    </div>

		</div>
		<header>
			<nav>
				<h1>play@!!</h1>
		<!-- 		<div class='user'>
					<h1><%= roomName %></h1>
					<h4><%= profileName %></h4>
					<img src="<%= profilePic %>" alt="<%= profileName %>">
				</div> -->
				<div id="userList">
		<!-- 			<div class="player">
						<div>
							<img src="" alt="">
							<p>name</p>
						</div>
						<div>####################</div>
					</div> -->
				</div>
			</nav>
		</header>
		<main id="roomMain">
			

		</main>
		
		<script>

		    var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];
		    var sphereShape2; /*temp*/
		    var sphereBody2Arr=[]; /*temp*/
		    var jason = [];
		    var camera, scene, renderer;
		    var geometry, material, mesh;
		    var controls,time = Date.now();
		    var radiant;
		    var loader = new THREE.TextureLoader();

		    var blocker = document.getElementById( 'blocker' );
		    var instructions = document.getElementById( 'instructions' );

		    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

		    if ( havePointerLock ) {

		        var element = document.body;
		        //if the poiter lock
		        var pointerlockchange = function ( event ) {

		            if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

		                controls.enabled = true;

		                blocker.style.display = 'none';

		            } else {
		                controls.enabled = false;
		                blocker.style.display = '-webkit-box';
		                blocker.style.display = '-moz-box';
		                blocker.style.display = 'box';
		                instructions.style.display = '';

		            }

		        }
		        // if the poiter denied
		        var pointerlockerror = function ( event ) {
		            instructions.style.display = '';
		        }

		        // Hook pointer lock state change events
		        document.addEventListener( 'pointerlockchange', pointerlockchange, false );
		        document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
		        document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

		        document.addEventListener( 'pointerlockerror', pointerlockerror, false );
		        document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
		        document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
		        document.getElementById("radiant").addEventListener("click", function(){
		        	// alert("radiant");
		        	controls.body.position.set(0,33,20);
		        	controls.mesh.position.set(0,33,20);

		        	socket.emit("teamReq", {
		        		team: "radiant",
		        		profilePic: profilePic,
		        		profileName: profileName,
		        		profileId: profileId,
		        		roomId: roomId
		        	});
		        })
		        document.getElementById("dire").addEventListener("click", function(){
		        	controls.body.position.set(0,33,-20);
		        	controls.mesh.position.set(0,33,-20);
		        	socket.emit("teamReq", {
		        		team: "dire",
		        		profilePic: profilePic,
		        		profileName: profileName,
		        		profileId: profileId,
		        		roomId: roomId
		        	});
		        })



		        instructions.addEventListener( 'click', function ( event ) {
		            instructions.style.display = 'none';
		
		            // Ask the browser to lock the pointer
		            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

		            if ( /Firefox/i.test( navigator.userAgent ) ) {

		                var fullscreenchange = function ( event ) {

		                    if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

		                        document.removeEventListener( 'fullscreenchange', fullscreenchange );
		                        document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

		                        element.requestPointerLock();
		                    }

		                }

		                document.addEventListener( 'fullscreenchange', fullscreenchange, false );
		                document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

		                element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

		                element.requestFullscreen();

		            } else {

		                element.requestPointerLock();

		            }

		        }, false );

		    } else {

		        instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

		    }

		    initCannon();
		    init();
		    animate();

		    function initCannon(){
		        // Setup our world
		        world = new CANNON.World();
		        world.quatNormalizeSkip = 0;
		        world.quatNormalizeFast = false;

		        var solver = new CANNON.GSSolver();

		        world.defaultContactMaterial.contactEquationStiffness = 1e9;
		        world.defaultContactMaterial.contactEquationRelaxation = 4;

		        solver.iterations = 7;
		        solver.tolerance = 0.1;
		        var split = true;
		        if(split)
		            world.solver = new CANNON.SplitSolver(solver);
		        else
		            world.solver = solver;

		        world.gravity.set(0,-20,0);
		        world.broadphase = new CANNON.NaiveBroadphase();

		        // Create a slippery material (friction coefficient = 0.0)
		        physicsMaterial = new CANNON.Material("slipperyMaterial");
		        var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
		                                                                physicsMaterial,
		                                                                0.0, // friction coefficient
		                                                                0.3  // restitution
		                                                                );
		        // We must add the contact materials to the world
		        world.addContactMaterial(physicsContactMaterial);

		        // Create a sphere
		        var mass = 5, radius = 1.3;
		        sphereShape = new CANNON.Sphere(radius);
		        sphereBody = new CANNON.Body({ mass: mass });
		        sphereBody.addShape(sphereShape);
		        sphereBody.position.set(0,5,0);
		        sphereBody.linearDamping = 0.9;
		        world.addBody(sphereBody);

		        // Create a plane
		        var groundShape = new CANNON.Plane();
		        var groundBody = new CANNON.Body({ mass: 0 });
		        groundBody.addShape(groundShape);
		        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
		        world.addBody(groundBody);
		    }

		    function init() {

		        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		        scene = new THREE.Scene();
		        scene.fog = new THREE.Fog(0xf3e9db, 0, 200 );
		        var ambient = new THREE.AmbientLight( 0x021238 );
		        scene.add( ambient );

		        light = new THREE.SpotLight( 0xefefe7 );
		        light.position.set( 10, 77, 20 );
		        light.target.position.set( 0, 0, 0 );
		        if(true){
		            light.castShadow = true;
		            light.intensity = 1.1;

		            light.shadowCameraNear = 20;
		            light.shadowCameraFar = 50;//camera.far;
		            light.shadowCameraFov = 40;

		            light.shadowMapBias = 0.1;
		            light.shadowMapDarkness = 0.7;
		            light.shadowMapWidth = 2*512;
		            light.shadowMapHeight = 2*512;

		            //light.shadowCameraVisible = true;
		        }
		        scene.add( light );

		        // socket.on("radiantRes", function(data){
		        // 	console.log(data.profileName+ " choose"+" THE RADIANT!!");
		        	
		        // })
		        // socket.on("direRes", function(data){
		        // 	console.log(data.profileName+ " choose"+" THE DIRE!!");
		        // 	renderPlayer()
		        // 	// createPlayer();
		        // })
		        var radiantTeam = [];
		        var direTeam = [];
		        var teams = radiantTeam.concat(direTeam);
		        socket.emit("reqCurrentPlayer", teams);


		        socket.on("radiantRes", function(data){
		        	// radiantTeam.push(id);
		        	console.log("radiantRes: ", data);
		        	renderPlayer({x:0, y:30, z: 20}, data.info.profileId, "blue");
		        })
		        socket.on("direRes", function(data){
		        	// direTeam.push(id);
		        	console.log("direRes: ", data);
		        	console.log("direRes: ", data.info);
		        	renderPlayer({x:0, y:30, z:-20}, data.info.profileId, "red");
		        })

 				
	        	controls = new PointerLockControls( camera , sphereBody, {
	        	    x : 0,
	        	    y : 10,
	        	    z : 20
	        	},"red", profilePic , profileName, roomId);

	        	scene.add( controls.getObject());
		        

		        function renderPlayer(objpos,id,color){
		        	var playerColor = ["pink", "salmon", "skyblue", "indogo", "red"]
		        	var x = objpos.x;
		        	var y = objpos.y;
		        	var z = objpos.z;
					// var texture = loader.load("https://pbs.twimg.com/profile_images/644308376323813376/iH0o0RL8_normal.png");
					var texture = loader.load("../../img/bg.jpg");
					// texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
					// texture.repeat.set(1000, 1000);
					var label = new THREE.BoxGeometry( 1, 1, 0.1);
					var material = new THREE.MeshBasicMaterial({
						color: color,
						// map: texture
					});
					var labelMesh = new THREE.Mesh( label, material );
					labelMesh.position.set(0,1.4,0);
					// scene.add( labelMesh )

		        	sphereShape2 = new CANNON.Sphere(1.3);
		        	sphereBody2 = new CANNON.Body({ mass: 5 });
		        	sphereBody2.addShape(sphereShape2);
		        	sphereBody2.position.set(0,5,0);
		        	sphereBody2.linearDamping = 0.9;
		        	sphereBody2.id = id;
		        	world.addBody(sphereBody2);
		        	var geometry = new THREE.SphereGeometry(1, 3,3 );
		        	var material = new THREE.MeshLambertMaterial( { 
		        		// map:floorTexture,
		        	    color: playerColor[Math.floor(Math.random()*playerColor.length)],
		        	    // transparent: true,
		        	    // opacity: 0.4
		        	     } );
		        	var jasonObject = new THREE.Mesh( geometry, material );
		        	jasonObject.add(labelMesh);
		        	jasonObject.id = id;
		        	sphereBody2.position.set(x,y,z);
		        	jasonObject.position.set(x,y,z);
		        	jason.push(jasonObject);
		        	sphereBody2Arr.push(sphereBody2);
		        	// console.log("jasonObject.position:from 284 ",jasonObject.position);
		        	scene.add(jasonObject);
		        	sphereBody2.addEventListener("collide",function(e){
		        	    // console.log("sphereBody2 attacked: ", sphereBody2.position);
		        	    socket.emit("otherCollid", {
		        	    	roomId: roomId,
		        	    	pos:sphereBody2.position
		        	    })
		        	});
		        }

		       
		            
		        


		        // var halfExtents = new CANNON.Vec3(1,1,1);
		        // var boxShape = new CANNON.Box(halfExtents);
		        // var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
		        // for(var i=0; i<3; i++){
		        //     var x = (Math.random()-0.5)*20;
		        //     var y = 10+ (Math.random()-0.5)*1;
		        //     var z = (Math.random()-0.5)*20;
		        //     var boxBody = new CANNON.Body({ mass: 5 });
		        //     boxBody.addShape(boxShape);
		        //     var boxMesh = new THREE.Mesh( boxGeometry, material );
		        //     world.addBody(boxBody);
		        //     scene.add(boxMesh);
		        //     boxBody.position.set(x,y,z);
		        //     boxMesh.position.set(x,y,z);
		        //     boxMesh.castShadow = true;
		        //     boxMesh.receiveShadow = true;
		        //     boxes.push(boxBody);
		        //     boxMeshes.push(boxMesh);





		        /*try*/
		        // camera1 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		        // controls = new PointerLockControls( camera1 , sphereBody );
		        // scene.add( controls.getObject() );




		        // console.info(controls);
		        // floor
		        geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
		        geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
		        var texture = loader.load("../../img/bg.jpg");
		        material = new THREE.MeshLambertMaterial( { 
		        	map: texture,
		        	color: 0xac5653 
		        } );

		        mesh = new THREE.Mesh( geometry, material );
		        mesh.castShadow = true;
		        mesh.receiveShadow = true;
		        scene.add( mesh );

		        renderer = new THREE.WebGLRenderer();
		        renderer.shadowMapEnabled = true;
		        renderer.shadowMapSoft = true;
		        renderer.setSize( window.innerWidth, window.innerHeight );
		        renderer.setClearColor( scene.fog.color, 1 );

		        document.body.appendChild( renderer.domElement );

		        window.addEventListener( 'resize', onWindowResize, false );
		        socket.emit("askBarrier");

		        socket.on("barrier", function(data){
		        	// Add boxes
		        	var halfExtents = new CANNON.Vec3(1,1,1);
		        	var boxShape = new CANNON.Box(halfExtents);
		        	var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
		        	for(var i=0; i<data.length; i++){
		        	    // var x = (Math.random()-0.5)*20;
		        	    // var y = 10+ (Math.random()-0.5)*1;
		        	    // var z = (Math.random()-0.5)*20;
		        	    // var x = (Math.random()-0.5)*20;
		        	    // var y = 10;
		        	    // var z = 0;
		        	    var x = data[i].x;
		        	    var y = data[i].y;
		        	    var z = data[i].z;
		        	    var boxBody = new CANNON.Body({ mass: 5 });
		        	    boxBody.addShape(boxShape);
		        	    boxBody.id = i;
		        	    // console.log(boxBody);
		        	    var boxMesh = new THREE.Mesh( boxGeometry, material );
		        	    world.addBody(boxBody);
		        	    scene.add(boxMesh);
		        	    boxBody.position.set(x,y,z);
		        	    boxMesh.position.set(x,y,z);
		        	    boxMesh.castShadow = true;
		        	    boxMesh.receiveShadow = true;
		        	    boxes[i]=boxBody;
		        	    boxMeshes.push(boxMesh);
		        	    boxBody.addEventListener("collide", function(e){
		        	    	// console.log(e.target);
		        	    	socket.emit("barrierChange", {
		        	    		roomId: roomId,
		        	    		barrierId: e.target.id,
		        	    		position: e.target.position
		        	    	})
		        	    })
		        	}
		        })




		        // Add linked boxes
		        // var size = 0.5;
		        // var he = new CANNON.Vec3(size,size,size*0.1);
		        // var boxShape = new CANNON.Box(he);
		        // var mass = 0;
		        // var space = 0.1 * size;
		        // var N = 5, last;
		        // var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
		        // for(var i=0; i<N; i++){
		        //     var boxbody = new CANNON.Body({ mass: mass });
		        //     boxbody.addShape(boxShape);
		        //     var boxMesh = new THREE.Mesh(boxGeometry, material);
		        //     boxbody.position.set(5,(N-i)*(size*2+2*space) + size*2+space,0);
		        //     boxbody.linearDamping = 0.01;
		        //     boxbody.angularDamping = 0.01;
		        //     // boxMesh.castShadow = true;
		        //     boxMesh.receiveShadow = true;
		        //     world.addBody(boxbody);
		        //     scene.add(boxMesh);
		        //     boxes.push(boxbody);
		        //     boxMeshes.push(boxMesh);

		        //     if(i!=0){
		        //         // Connect this body to the last one
		        //         var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
		        //         var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
		        //         world.addConstraint(c1);
		        //         world.addConstraint(c2);
		        //     } else {
		        //         mass=0.3;
		        //     }
		        //     last = boxbody;
		        // }
		    }

		    function onWindowResize() {
		        camera.aspect = window.innerWidth / window.innerHeight;
		        camera.updateProjectionMatrix();
		        renderer.setSize( window.innerWidth, window.innerHeight );
		    }

	
		        // var update = function ( delta ) {

		        //     if ( scope.enabled === false ) return;

		        //     delta *= 0.1;

		        //     otherInputVelocity.set(0,0,0);

		        //     if ( moveForward ){
		        //         otherInputVelocity.z = -velocityFactor * delta;
		        //     }
		        //     if ( moveBackward ){
		        //         otherInputVelocity.z = velocityFactor * delta;
		        //     }

		        //     if ( moveLeft ){
		        //         otherInputVelocity.x = -velocityFactor * delta;
		        //     }
		        //     if ( moveRight ){
		        //         otherInputVelocity.x = velocityFactor * delta;
		        //     }
		        //     // Convert velocity to world coordinates
		        //     otherEuler.x = pitchObject.rotation.x; //camera
		        //     otherEuler.y = yawObject.rotation.y; //camera object
		        //     // console.log(otherEuler);
		        //     otherEuler.order = "XYZ";
		        //     quat.setFromEuler(otherEuler);
		        //     otherInputVelocity.applyQuaternion(quat);
		        //     //quat.multiplyVector3(otherInputVelocity);

		        //     // Add to the object
		        //     velocity.x += otherInputVelocity.x;
		        //     velocity.z += otherInputVelocity.z;
		        //     // console.log("velocity: ", velocity);
		        //     yawObject.position.copy(cannonBody.position);
		        // };
		    
		        
		    var dt = 1/60;
		    var mf = false; /*moveforward*/
		    var mb = false; /*notmoveBackward*/
		    var ml = false; /*notmoveLeft*/
		    var mr = false; /*notmoveRight*/
		    var otherInputVelocity = new THREE.Vector3();
		    var otherEuler = new THREE.Euler();
		    var quat = new THREE.Quaternion();
		    socket.on("moveForward", function(data){
		    	// console.log("moveForward: ", data);
		    	mf = true;
		    })
		    socket.on("notmoveForward", function(data){
		    	// console.log("notmoveForward: ", data);
		    	mf = false;
		    })
		    socket.on("moveBackward", function(data){
		    	// console.log("moveBackward: ", data);
		    	mb= true;
		    })
		    socket.on("notmoveBackward", function(data){
		    	// console.log("notmoveBackward: ", data);
		    	mb = false;
		    })
		    socket.on("moveLeft", function(data){
		    	// console.log("moveLeft: ", data);
		    	ml= true;
		    })
		    socket.on("notmoveLeft", function(data){
		    	// console.log("notmoveLeft: ", data);
		    	ml = false;
		    })
		    socket.on("moveRight", function(data){
		    	// console.log("moveRight: ", data);
		    	mr= true;
		    })
		    socket.on("notmoveRight", function(data){
		    	// console.log("notmoveRight: ", data);
		    	mr = false;
		    })

		    socket.on("pos",function(data){
		    	console.log(jason);
		    	var temp, temp2;
		    	for (var i = 0; i < jason.length; i++) {
		    		if(jason[i].id== data.profileId){
		    			temp = jason[i];
		    		}
		    	};
		    	for (var j = 0; j< sphereBody2Arr.length; j++) {
		    		if(sphereBody2Arr[j].id== data.profileId){
		    			temp2 = sphereBody2Arr[j];
		    		}
		    		console.log(sphereBody2Arr[j]);
		    	};

		    	console.log(temp);
		    	console.log(temp2);
		    	console.log(data);
		    	temp.position.set(data.position.x, data.position.y, data.position.z);
		    	temp2.position.set(data.position.x, data.position.y, data.position.z);
		    })


		    function animate() {

		        requestAnimationFrame( animate );
		        // yawObject.position.copy(sphereBody2.position);
		        // console.log("sphereBody2.position: ",sphereBody2.position);
		        // console.log("yawObject.position: ", jason[0].position);
		        // jason[0].position.copy(sphereBody2.position)
		        
	        	// console.log(data.velocity);

	        	var delta = Date.now() - time ;
	        	for (var i = 0; i < jason.length; i++) {
	        		// delta *= 0.1;

	        		// otherInputVelocity.set(0,0,0);

	        		// if ( mf ){
	        		//     otherInputVelocity.z = - 0.2 * delta;
	        		// }
	        		// if ( mb ){
	        		//     otherInputVelocity.z = 0.2 * delta;
	        		// }

	        		// if ( ml ){
	        		//     otherInputVelocity.x = -0.2 * delta;
	        		// }
	        		// if ( mr ){
	        		//     otherInputVelocity.x = 0.2 * delta;
	        		// }
	        		// // // Convert velocity to world coordinates
	        		// otherEuler.x = 22; //camera
	        		// // otherEuler.x = pitchObject.rotation.x; //camera
	        		// // otherEuler.y = yawObject.rotation.y; //camera object
	        		// // // socket.on("rotation", function(data){
	        		// // // 	console.log(data);
	        		// // otherEuler.y += 0.1; //camera object
	        		// // // })
	        		// console.log("otherEuler: ", otherEuler);
	        		// otherEuler.y = 11; //camera object
	        		// otherEuler.order = "XYZ";
	        		// quat.setFromEuler(otherEuler);
	        		// otherInputVelocity.applyQuaternion(quat);
	        		// // quat.multiplyVector3(otherInputVelocity);

	        		// // // Add to the object
	        		// sphereBody2Arr[i].velocity.x += otherInputVelocity.x;
	        		// sphereBody2Arr[i].velocity.z += otherInputVelocity.z;
	        		// // console.log("velocity: ", velocity);
	        		// yawObject.position.copy(cannonBody.position);

	        	    jason[i].position.copy(sphereBody2Arr[i].position);
	        	    // console.log("");
	        	};
		        


		        if(controls.enabled){
		            world.step(dt);

		            // Update ball positions
		            for(var i=0; i<balls.length; i++){
		                ballMeshes[i].position.copy(balls[i].position);
		                ballMeshes[i].quaternion.copy(balls[i].quaternion);
		            }

		            // Update box positions
		            for(var i=0; i<boxes.length; i++){
		                boxMeshes[i].position.copy(boxes[i].position);
		                boxMeshes[i].quaternion.copy(boxes[i].quaternion);
		            }
		        }
    	        socket.on("barrierChange", function(data){
            		// console.log(boxes[data.barrierId].position);
            		// console.log("barrierChange: ", data);
            		// boxes[data.barrierId].velocity.set(data.position.x, data.position.y, data.position.z );
            		boxes[data.barrierId].position.set(data.position.x, data.position.y, data.position.z );
    	            boxMeshes[data.barrierId].position.copy(boxes[data.barrierId].position);
            	})
		        controls.update( Date.now() - time );
		        renderer.render( scene, camera );
		        time = Date.now();

		    }


// ****************************************************************************
// *                                  bullet                                  *
// ****************************************************************************

		    var ballShape = new CANNON.Sphere(0.2);
		    var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
		    var shootDirection = new THREE.Vector3();
		    var shootVelo = 100; /*shoot speed*/
		    var projector = new THREE.Projector();
		    function getShootDir(targetVec){
		        var vector = targetVec;
		        targetVec.set(0,0,1);
		        projector.unprojectVector(vector, camera);
		        var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
		        // console.log("ray.direaction: ", ray.direction);
		        targetVec.copy(ray.direction);
		    }
		    socket.on("attacking", function(data){
		    	console.log(sphereBody2Arr);
		    	var temp;
		    	for (var i = 0; i < sphereBody2Arr.length; i++) {
		    		// console.log(sphereBody2Arr[i].id);
		    		if(sphereBody2Arr[i].id == data.profileId){
		    			temp = sphereBody2Arr[i];
		    		}
		    	};
		    	console.log("body : ", temp.position);
		    	console.log(data + " is attacking");
		    	var x = temp.position.x;
		    	var y = temp.position.y;
		    	var z = temp.position.z;
		    	var ballBody = new CANNON.Body({ mass: 11 }); /*the dencity of bullets*/
		    	ballBody.addShape(ballShape);
		    	world.addBody(ballBody);
		    	var ballMesh = new THREE.Mesh( ballGeometry, material );
		    	scene.add(ballMesh);
		    	ballMesh.castShadow = true;
		    	ballMesh.receiveShadow = true;
		    	balls.push(ballBody);
		    	ballMeshes.push(ballMesh);
		    	// getShootDir(shootDirection);
		    	ballBody.velocity.set(data.x * shootVelo,  data.y * shootVelo, data.z * shootVelo);
		    	// Move the ball outside the player sphere
		    	x += data.x * (sphereShape.radius*1.02 + ballShape.radius);
		    	y += data.y * (sphereShape.radius*1.02 + ballShape.radius);
		    	z += data.z * (sphereShape.radius*1.02 + ballShape.radius);
		    	ballBody.position.set(x,y,z);
		    	ballMesh.position.set(x,y,z);
		    });
		    /*bullet*/
		    window.addEventListener("click",function(e){
		        if(controls.enabled==true){
		            var x = sphereBody.position.x;
		            var y = sphereBody.position.y;
		            var z = sphereBody.position.z;
		            var ballBody = new CANNON.Body({ mass: 11 }); /*the dencity of bullets*/
		            ballBody.addShape(ballShape);
		            world.addBody(ballBody);
		            var ballMesh = new THREE.Mesh( ballGeometry, material );
		            scene.add(ballMesh);
		            ballMesh.castShadow = true;
		            ballMesh.receiveShadow = true;
		            balls.push(ballBody);
		            ballMeshes.push(ballMesh);
		            getShootDir(shootDirection);
		            console.log("shootDirection: ,", shootDirection);
		            socket.emit("shoot", {
		            	roomId,
		            	profileId,
		            	directionX:shootDirection.x,
		            	directionY:shootDirection.y,
		            	directionZ:shootDirection.z
		            });
		            ballBody.velocity.set(shootDirection.x * shootVelo,  shootDirection.y * shootVelo, shootDirection.z * shootVelo);
		            // Move the ball outside the player sphere
		            x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
		            y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
		            z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
		            ballBody.position.set(x,y,z);
		            ballMesh.position.set(x,y,z);
		        }
		    });

		</script>

	</body>
</html>